{% extends 'base.html' %}
{% load static %}

{% block javascript %}
  {{ block.super }}


  <script>
    document.addEventListener("DOMContentLoaded", function () {
      // Helpers
      const toNote = (hz, a4 = 440) => {
        if (!hz || hz <= 0) return {name: '–', cents: 0, targetHz: 0, midi: NaN};
        const n = Math.round(12 * Math.log2(hz / a4) + 69);
        const cents = 1200 * Math.log2(hz / (a4 * Math.pow(2, (n - 69) / 12)));
        const names = ['C', 'C♯', 'D', 'D♯', 'E', 'F', 'F♯', 'G', 'G♯', 'A', 'A♯', 'B'];
        const name = names[((n % 12) + 12) % 12] + (Math.floor(n / 12) - 1);
        const targetHz = a4 * Math.pow(2, (n - 69) / 12);
        return {name, cents, targetHz, midi: n};
      };
      const hzForMidi = (midi, a4 = 440) => a4 * Math.pow(2, (midi - 69) / 12);

      // Worklet path
      const workletPath = "{% static 'tuning/js/pitch-worklet.js' %}";

      // State
      let a4 = 440;
      let ctx, node, mediaStream;
      let silenceThresholdDb = -70; // adjustable via UI

      // Data buffers (10s window)
      const timeSeries = [];
      const freqSeries = [];
      const freqSmoothSeries = [];
      const WINDOW_SEC = 10;

      // Smoothing for top graph (time-aware exponential smoothing)
      const SMOOTH_TAU = 0.5; // seconds
      let lastSmoothHz = null;
      let lastSmoothT = null;

      // Canvas
      const fullCanvas = document.getElementById('freq-full');
      const fullCtx = fullCanvas?.getContext('2d') || null;

      function fitCanvasDPR(c) {
        const rawDpr = window.devicePixelRatio || 1;
        const dpr = Math.min(rawDpr, 1.5); // cap DPR to reduce mobile GPU load
        const cssW = c.clientWidth;
        const cssH = c.clientHeight;
        if (!cssW || !cssH) return;
        c.width = Math.round(cssW * dpr);
        c.height = Math.round(cssH * dpr);
      }

      [fullCanvas].forEach(c => c && fitCanvasDPR(c));
      window.addEventListener('resize', () => {
        [fullCanvas].forEach(c => c && fitCanvasDPR(c));
      });

      function drawAxes(ctx, w, h, yMin, yMax, title) {
        ctx.clearRect(0, 0, w, h);
        ctx.save();
        ctx.strokeStyle = '#1f2436';
        ctx.fillStyle = '#9aa3af';
        ctx.lineWidth = 1;
        const pad = 36; // left padding for y labels
        const x0 = pad, y0 = h - 20, x1 = w - 10, y1 = 10;
        // axes
        ctx.beginPath();
        ctx.moveTo(x0, y0);
        ctx.lineTo(x1, y0); // x axis
        ctx.moveTo(x0, y0);
        ctx.lineTo(x0, y1); // y axis
        ctx.stroke();
        // title
        if (title) {
          ctx.fillStyle = '#e6e6e6';
          ctx.font = '12px system-ui';
          ctx.fillText(title, x0, y1 + 10);
        }
        // y ticks (4)
        ctx.fillStyle = '#9aa3af';
        ctx.font = '11px system-ui';
        for (let i = 0; i <= 4; i++) {
          const t = i / 4;
          const y = y0 - t * (y0 - y1);
          const v = yMin + t * (yMax - yMin);
          ctx.strokeStyle = '#1f2436';
          ctx.beginPath();
          ctx.moveTo(x0, y);
          ctx.lineTo(x1, y);
          ctx.stroke();
          ctx.fillText(v.toFixed(1) + ' Hz', 4, y + 4);
        }
        ctx.restore();
        return {padLeft: x0, padTop: y1, padBottom: h - y0, padRight: w - x1};
      }

      function drawDots(ctx, w, h, x0, y0, x1, y1, seriesT, seriesY, tStart, tEnd, yMin, yMax, color, hideOffY) {
        const padLeft = x0, padTop = y1, padBottom = h - y0, padRight = w - x1;
        const plotL = padLeft, plotR = w - padRight, plotT = padTop, plotB = h - padBottom;
        const plotW = plotR - plotL, plotH = plotB - plotT;
        if (seriesT.length < 1) return;
        const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
        ctx.save();
        ctx.fillStyle = color || '#e6e6e6';
        const r = Math.max(1.5, Math.min(3.5, Math.round(Math.min(w, h) / 120)));
        for (let i = 0; i < seriesT.length; i++) {
          const t = seriesT[i];
          const y = seriesY[i];
          if (t < tStart || t > tEnd) continue;
          const px = plotL + (t - tStart) / (tEnd - tStart) * plotW;
          if (hideOffY && (y < yMin || y > yMax)) continue;
          const yPlotted = hideOffY ? y : clamp(y, yMin, yMax);
          const py = plotB - (yPlotted - yMin) / (yMax - yMin) * plotH;
          ctx.beginPath();
          ctx.arc(px, py, r, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      }

      function redraw(nowT) {
        if (!fullCtx) return;
        const w1 = fullCanvas.width, h1 = fullCanvas.height;
        const tEnd = nowT;
        const tStart = tEnd - WINDOW_SEC;

        // Determine Y range for full graph from smoothed data (with margins) without extra allocations
        let haveY = false;
        let rawMin = Infinity;
        let rawMax = -Infinity;
        for (let i = 0; i < timeSeries.length; i++) {
          const tt = timeSeries[i];
          if (tt < tStart) continue;
          const yy = freqSmoothSeries[i];
          if (!Number.isFinite(yy)) continue;
          if (yy < rawMin) rawMin = yy;
          if (yy > rawMax) rawMax = yy;
          haveY = true;
        }
        let yMin = 60, yMax = 1200; // sensible defaults for instruments
        if (haveY) {
          yMin = Math.max(20, rawMin);
          yMax = Math.max(yMin + 1, rawMax);
          const pad = (yMax - yMin) * 0.1 + 1;
          yMin = Math.max(20, yMin - pad);
          yMax = Math.min(20000, yMax + pad);
        }

        drawAxes(fullCtx, w1, h1, yMin, yMax, 'Frequency over time (10s, smoothed)');
        drawDots(fullCtx, w1, h1, 36, h1 - 20, w1 - 10, 10, timeSeries, freqSmoothSeries, tStart, tEnd, yMin, yMax, '#60a5fa', true);

      }

      let rafId = 0;

      function trimOld(tCut) {
        // Find first index within window and remove in one splice to avoid repeated shifts
        let idx = 0;
        const len = timeSeries.length;
        while (idx < len && timeSeries[idx] < tCut) idx++;
        if (idx > 0) {
          timeSeries.splice(0, idx);
          freqSeries.splice(0, idx);
          freqSmoothSeries.splice(0, idx);
        }
      }

      function tick() {
        // Continuously advance the window and redraw, even during silence
        if (ctx && ctx.state !== 'closed') {
          const tNow = ctx.currentTime;
          const tCut = tNow - WINDOW_SEC;
          trimOld(tCut);
          redraw(tNow);
        }
        rafId = requestAnimationFrame(tick);
      }

      async function start() {
        const btn = document.getElementById('startBtn');
        btn.disabled = true;
        try {
          mediaStream = await navigator.mediaDevices.getUserMedia({
            audio: {echoCancellation: false, noiseSuppression: false, autoGainControl: false, channelCount: 1}
          });
        } catch (e) {
          alert('Microphone permission is required.');
          console.error('getUserMedia error:', e);
          btn.disabled = false;
          return;
        }

        try {
          ctx = new (window.AudioContext || window.webkitAudioContext)({latencyHint: 'interactive'});
          await ctx.audioWorklet.addModule(workletPath);
          await ctx.resume();

          const src = ctx.createMediaStreamSource(mediaStream);
          node = new AudioWorkletNode(ctx, 'pitch-worklet', {
            processorOptions: {sampleRate: ctx.sampleRate, windowSize: 4096, hopSize: 240}
          });

          const sink = ctx.createGain();
          sink.gain.value = 0;
          src.connect(node);
          node.connect(sink).connect(ctx.destination);

          node.port.onmessage = (ev) => {
            const {hz, rms, t, conf} = ev.data || {};
            if (!Number.isFinite(hz) || !Number.isFinite(rms) || !Number.isFinite(t)) return;
            if (window.updateDbMeter) window.updateDbMeter(rms);
            // Keep charts rolling even when below min dB: just trim window; RAF will redraw
            if (rms < silenceThresholdDb) {
              const tCut = t - WINDOW_SEC;
              trimOld(tCut);
              return;
            }
            if (!Number.isFinite(conf) || conf < 0.6) return; // ignore low-confidence detections
            if (hz <= 0) return; // ignore invalid frequency
            // Compute smoothed frequency (time-aware EMA)
            let sHz;
            if (lastSmoothHz == null || !Number.isFinite(lastSmoothHz)) {
              sHz = hz;
            } else {
              const dt = Math.max(0, t - (lastSmoothT ?? t));
              const alpha = 1 - Math.exp(-dt / SMOOTH_TAU);
              sHz = lastSmoothHz + alpha * (hz - lastSmoothHz);
            }
            lastSmoothHz = sHz;
            lastSmoothT = t;

            timeSeries.push(t);
            freqSeries.push(hz);
            freqSmoothSeries.push(sHz);
            // drop older than 10s
            const tCut = t - WINDOW_SEC;
            trimOld(tCut);
          };

          // Start animation loop if not already running
          if (!rafId) {
            rafId = requestAnimationFrame(tick);
          }

          console.log('Audio started. sampleRate=', ctx.sampleRate);
        } catch (e) {
          console.error('AudioWorklet setup failed:', e);
          alert('Audio engine failed to start. See console for details.');
          btn.disabled = false;
        }
      }

      document.getElementById('startBtn').addEventListener('click', start);

      // dB UI bindings
      const minDbInput = document.getElementById('minDb');
      const minDbOut = document.getElementById('minDbVal');
      const dbFill = document.getElementById('dbFill');
      const dbText = document.getElementById('dbText');
      let dbSmooth = 0;

      function setMinDb(v) {
        silenceThresholdDb = Number(v);
        if (minDbOut) minDbOut.textContent = `${silenceThresholdDb.toFixed(0)} decibels`;
      }

      if (minDbInput) {
        setMinDb(minDbInput.value);
        minDbInput.addEventListener('input', (e) => setMinDb(e.target.value));
      }

      // Update meter on each frame
      window.updateDbMeter = function (db) {
        if (!dbFill) return;
        const norm = Math.max(0, Math.min(1, (db + 100) / 100));
        // simple exponential smoothing to reduce jumps
        dbSmooth = dbSmooth * 0.85 + norm * 0.15;
        dbFill.style.width = `${(dbSmooth * 100).toFixed(0)}%`;
        if (dbText) dbText.textContent = `${db.toFixed(1)} decibels`;
        dbFill.classList.toggle('bg-success', db >= silenceThresholdDb);
        dbFill.classList.toggle('bg-secondary', db < silenceThresholdDb);
      };
    });
  </script>
{% endblock javascript %}

{% block content %}
  <div class="container-fluid py-3">

    <div class="row g-3 align-items-center mb-3">
      <div class="col-auto">
        <button id="startBtn" class="btn btn-primary">Start mic</button>
      </div>
      <div class="col">
        <div class="d-flex align-items-center gap-3 flex-wrap">
          <div class="d-inline-flex align-items-center gap-2 flex-nowrap">
            <label for="minDb" class="form-label mb-0">Min decibels</label>
            <input id="minDb" type="range" class="form-range" min="-100" max="0" step="1" value="-70" style="width:200px;"/>
            <div id="minDbVal" class="text-muted small">-70 decibels</div>
          </div>
          <div class="d-inline-flex align-items-center" aria-label="Input level">
            <div class="progress" style="width:160px; height:10px;" title="Live decibel level">
              <div id="dbFill" class="progress-bar bg-secondary" role="progressbar" style="width: 0%"></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="card-body">
        <canvas id="freq-full" class="w-100" style="height:260px;"></canvas>
      </div>
    </div>

    <div class="card mt-3" role="region" aria-label="Tuning instructions">
      <div class="card-body">
        <p class="mb-0">
          Use this tuner to practice note consistency. Start the mic, play a comfortable long tone,
          and try to keep the dots at a steady height over time.
        </p>
      </div>
    </div>
  </div>
{% endblock content %}

<style>
  .draggable {
    cursor: move;
    transition: transform 0.1s ease;
    border: 2px dashed #007bff !important;
    box-shadow: 0 0 10px rgba(0, 123, 255, 0.5) !important;
  }

  .draggable:hover {
    transform: scale(1.05);
  }
</style>

<div>
  <!-- Toggle button with gear icon -->
  <div class="d-flex align-items-center mb-2">
    <button class="btn btn-light btn-sm" type="button" id="valveToggleButton">
      <i class="text-muted fas text-faded fa-up-down-left-right"></i> <span id="toggleButtonText">Reposition</span>
    </button>
    <button id="reset-button" class="btn btn-light btn-sm ms-2">Reset</button>
  </div>

</div>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    // --- Cached Elements ---
    const valves_container = document.getElementById('trumpet-right');
    const valves = valves_container.children;

    const instrument_input_reset = document.getElementById('reset-button');

    const valveToggleButton = document.getElementById('valveToggleButton');
    const toggleButtonText = document.getElementById('toggleButtonText');

    // --- Constants ---
    const valvePositionsCacheKey = "valvePositionsCache";

    // Detect if user is on a mobile device
    const isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

    const initialValvePositions = [...valves].map(valve => ({
      top: parseInt(valve.style.top || '0'),
      right: parseInt(valve.style.right || '0'),
    }));


    // --- Reset Function ---
    function reset_valves() {
      // Reset valve positions to their original positions as specified in the HTML
      for (let i = 0; i < valves.length; i++) {
        // Remove any transform styles to restore original position
        valves[i].style.transform = '';
        // Clear any other positioning styles that might have been added
        valves[i].style.top = '';
        valves[i].style.right = '';
        valves[i].style.bottom = '';
        valves[i].style.left = '';
      }

      // Clear cache
      localStorage.removeItem(valvePositionsCacheKey);

      console.log("Valve positions reset to original HTML positions, cache cleared");
    }

    // --- Drag Functionality ---
    let isDragMode = false;
    let draggedValve = null;
    let startX, startY, startTop, startRight;

    // Function to enable/disable drag mode
    function toggleDragMode() {
      isDragMode = !isDragMode;

      if (isDragMode) {
        // Enable drag mode
        toggleButtonText.textContent = "Save Positions";
        enableValveDragging();
      } else {
        // Disable drag mode and save positions
        toggleButtonText.textContent = "Enable Drag Mode";
        disableValveDragging();
        saveValvePositionsToCache();
      }
    }

    // Enable dragging on all valves
    function enableValveDragging() {
      for (let i = 0; i < valves.length; i++) {
        valves[i].classList.add("draggable");
        valves[i].addEventListener("mousedown", startDrag);
        valves[i].addEventListener("touchstart", startDrag, { passive: false });
      }
      document.addEventListener("mousemove", drag);
      document.addEventListener("touchmove", drag, { passive: false });
      document.addEventListener("mouseup", endDrag);
      document.addEventListener("touchend", endDrag);
    }

    // Disable dragging on all valves
    function disableValveDragging() {
      for (let i = 0; i < valves.length; i++) {
        valves[i].classList.remove("draggable");
        valves[i].removeEventListener("mousedown", startDrag);
        valves[i].removeEventListener("touchstart", startDrag);
      }
      document.removeEventListener("mousemove", drag);
      document.removeEventListener("touchmove", drag);
      document.removeEventListener("mouseup", endDrag);
      document.removeEventListener("touchend", endDrag);
    }

    // Start dragging a valve
    function startDrag(e) {
      e.preventDefault();

      // Get the valve element
      draggedValve = e.target;

      // Get the starting position
      const touch = e.type === 'touchstart' ? e.touches[0] : e;
      startX = touch.clientX;
      startY = touch.clientY;

      // Get the current position of the valve
      const computedStyle = window.getComputedStyle(draggedValve);
      const transform = computedStyle.transform;

      // Extract the translate values from the transform matrix
      if (transform && transform !== 'none') {
        const matrix = new DOMMatrix(transform);
        startRight = matrix.m41; // translateX value
        startTop = matrix.m42;   // translateY value
      } else {
        startRight = 0;
        startTop = 0;
      }
    }

    // Drag the valve
    function drag(e) {
      if (!draggedValve) return;

      e.preventDefault();

      // Get the current position
      const touch = e.type === 'touchmove' ? e.touches[0] : e;
      const deltaX = touch.clientX - startX;
      const deltaY = touch.clientY - startY;

      // Update the valve position
      const newRight = startRight + deltaX;
      const newTop = startTop + deltaY;

      // Apply the new position
      draggedValve.style.transform = `translate3d(${newRight}px, ${newTop}px, 0)`;
    }

    // End dragging
    function endDrag() {
      draggedValve = null;
    }

    // Save valve positions to cache
    function saveValvePositionsToCache() {
      const positions = [];

      for (let i = 0; i < valves.length; i++) {
        const computedStyle = window.getComputedStyle(valves[i]);
        const transform = computedStyle.transform;

        let translateX = 0;
        let translateY = 0;

        if (transform && transform !== 'none') {
          const matrix = new DOMMatrix(transform);
          translateX = matrix.m41;
          translateY = matrix.m42;
        }

        positions.push({
          index: i,
          translateX: translateX,
          translateY: translateY
        });
      }

      localStorage.setItem(valvePositionsCacheKey, JSON.stringify(positions));
      console.log("Valve positions saved to cache:", positions);
    }

    // Load valve positions from cache
    function loadValvePositionsFromCache() {

      return
      try {
        const cachedPositions = localStorage.getItem(valvePositionsCacheKey);

        if (cachedPositions) {
          const positions = JSON.parse(cachedPositions);

          for (let i = 0; i < positions.length; i++) {
            const position = positions[i];
            const valve = valves[position.index];

            if (valve) {
              valve.style.transform = `translate3d(${position.translateX}px, ${position.translateY}px, 0)`;
            }
          }

          console.log("Valve positions loaded from cache:", positions);
        }
      } catch (error) {
        console.error("Error loading valve positions from cache:", error);
      }
    }

    // --- Event Listeners ---
    valveToggleButton.addEventListener('click', toggleDragMode);
    instrument_input_reset.addEventListener('click', reset_valves);

    // Load valve positions from cache
    loadValvePositionsFromCache();
  });
</script>
